{
  "hash": "863f33edcf8131db63cd057c842fcba4",
  "result": {
    "markdown": "---\ntitle: \"Exercise 02\"\norder: 2\nstatus: Available\ndate-due: 2023-09-11\ndate-modified: last-modified\n---\n\n\n::: {.callout-important appearance=\"minimal\" icon=\"true\"}\nExercise due on {{< meta date-due >}}\n:::\n\nℹ️ See [week {{< meta order >}}](https://bldgspatialdata.github.io/website/weeks/week_0{{< meta order >}}.html) for related slides and readings\n\n## Overview\n\n::: {.callout-tip collapse=\"false\" appearance=\"default\" icon=\"true\"}\n## Practice these skills\n\n-   Build a layered plot using `ggplot()`, `aes()`, and different `geom_` functions\n-   Explore the difference between discrete and continuous variables\n-   Use `coord_sf()` to modify a plot created with `geom_sf()`\n:::\n\n::: {.callout-note collapse=\"false\" appearance=\"default\" icon=\"true\"}\n## Think about these questions\n\n-   What makes a scale better or worse at visualizing data?\n-   How do you write a clear and accurate title, legend, or caption?\n-   When is it appropriate to modify the geometry of your data when making a map?\n:::\n\n## Setup\n\nThis exercises uses the `{ggplot2}` and `{dplyr}` packages (both from the [tidyverse family](https://www.tidyverse.org/) of packages) and the `{sf}` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(sf)\n```\n:::\n\n\nFor this week's exercise, we are also going to use data from the `{rnaturalearth}` package. Make sure to install those packages and re-start your session if these packages are not installed already:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# pak::pkg_install(c(\"rnaturalearth\", \"rnaturalearthdata\"))\nlibrary(rnaturalearth)\n```\n:::\n\n\nWe are going to use `ne_download()` to download the `countries` dataset and then use `st_centroid()` to make a version of this dataset where the features show the center of each country instead of the boundaries:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncountries <- ne_download(scale = \"medium\", type = \"countries\", returnclass = \"sf\")\n\ncountries <- st_transform(countries, crs = 3857)\n\ncountries_center <- st_centroid(countries)\n\nglimpse(countries)\n```\n:::\n\n\nSome of the following exercises don't require a sf object. You can also use the `mpg` or `storms` dataset we looked at during this week's lecture: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(mpg)\n\nglimpse(storms)\n```\n:::\n\n\n\nOne advantage of using `{ggplot2}` over a map-making focused package like `{tmap}` is the wide variety of extension packages created by the large community of users and developers making data visualizations (including maps) with `{ggplot2}`.\n\nWe aren't going to use some of these extension packages (and others) but we won't load them yet. Run the following code to install (and don't forget to restart your session afterwards):\n\n\n::: {.cell}\n\n```{.r .cell-code}\npak::pkg_install(c(\"patchwork\", \"plotly\", \"smoothr\"))\n```\n:::\n\n\nIf you finish this exercise but still want more practice, you can download this [RMarkdown document with exercises](https://github.com/thomasp85/ggplot2_workshop/blob/master/exercises.Rmd) shared by Thomas Lin Pedersen for his two-part 2020 online workshop on `{ggplot2}` ([part 1](https://www.youtube.com/watch?v=h29g21z0a68) and [part 2](https://www.youtube.com/watch?v=0m4yywqNPVY) are both available on YouTube).\n\n## Exercises\n\n### Plotting a single variable\n\nFind a discrete variable in countries and then create a plot with `geom_bar()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = countries) +\n  geom_bar(mapping = aes(x = ))\n```\n:::\n\n\nNext, find a continuous variable and make a plot with `geom_histogram()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = countries) +\n  geom_histogram(mapping = aes(x = ____))\n```\n:::\n\n\nNow, let's make a map! Use `countries_center` and `geom_sf()` to make a map with a continuous variable mapped to size:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = countries_center) +\n  geom_sf(aes(size = ____))\n```\n:::\n\n\n----\n\nNext, make a map with `geom_sf()` with one discrete variable mapped to color:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = countries) +\n  geom_sf(aes(color = ____))\n```\n:::\n\n\nIs that the map you expected? Try it again with the discrete variable mapped to fill:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = countries) +\n  geom_sf(aes(fill = ____))\n```\n:::\n\n\n----\n\nNow, make a plot using any `geom` function of your choice:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = countries) +\n  ____\n```\n:::\n\n\nExplain in plain language. What does your map show? ____\n\n### Plotting two variables\n\nFor this next section, you can continue to use `countries` as your dataset or load a different dataset using `{rnaturaleath}`. You can see what vector data is available using `rnaturalearth::ne_find_vector_data()` then find the function you need to load the data into a new object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrnaturalearth::ne_find_vector_data()\n```\n:::\n\n\nFirst, find two continuous variables and create a scatter plot with `geom_point()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = ____) +\n  geom_point(aes(____))\n```\n:::\n\n\nNext, look in your data for one discrete and one continuous variable then use `aes()` to set those variables for `geom_col()`. The `geom_col()` function is similar to `geom_bar()` but you *must* provide *both* an x *and* a y variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = ____) +\n  geom_col(aes(____))\n```\n:::\n\n\nNow, use `geom_sf()` mapping your continous variable to fill or color and your discrete variable to `facet_wrap()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = ____) +\n  geom_sf(aes(____)) +\n  facet_wrap(~ ____)\n```\n:::\n\n\nFinally, create a map using a different aesthetic that we haven't tried yet. Options could include `linewidth`, `size`, `alpha`, or `linetype`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = ____) +\n  geom_sf(aes(____ = ____))\n```\n:::\n\n\nIs this aesthetic mapping an effective way of visualizing the variable? ____\n\nIf so, why do you think it works well? If not, why does it *not* work well? ____\n\n### Using scales and colors\n\n `{ggplot2}` uses naming conventions to organize the scale functions. This isn't the same for every function but they look something like: \"scale_<aesthetic>_<color scheme>_<type of data>\". So, `scale_fill_viridis_d()` applies the Viridis color scale to a discrete variable mapped to the fill aesthetic.\n \nUse the data to create a plot and take a look at the colors set when you use `scale_color_viridis_c()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(____) +\n  geom_dotplot(aes(____, _____, color = ____)) +\n  scale_color_viridis_c()\n```\n:::\n\n\nThe [ColorBrewer](https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3) scales are designed for use with [thematic maps](https://en.wikipedia.org/wiki/Thematic_map). Use `?scale_color_brewer()` to pull up the documentation for this function and review the information on the type and palette parameters.\n\nNow, map a variable to the `color` aesthetic for `geom_sf()` and assign an appropriate type and palette value:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(____) +\n  geom_sf(aes(color = ____)) +\n  scale_color_brewer(type = ____, palette = ____)\n```\n:::\n\n\nSwitching from `color` to `fill`, try it again with a different type and palette value:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(____) +\n  geom_sf(aes(fill = ____)) +\n  scale_fill_brewer(type = ____, palette = ____)\n```\n:::\n\n\nOne last time, but we're using `scale_fill_distiller()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(____) +\n  geom_sf(aes(fill = ____)) +\n  scale_fill_distiller(type = ____, palette = ____)\n```\n:::\n\n\nNote that this `scale_fill_distiller()` scale only works with continuous values. If you get an error, you may need to map a different variable to `fill`.\n\n### Adding labels, legends, and themes\n\nSet the data for `ggplot()` and then use the `labs()` function to apply a title and caption that make sense:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = ____) +\n  geom_sf(color = \"black\", fill = NA) +\n  labs(\n    title = ____,\n    caption = ____\n  )\n```\n:::\n\n\nNow, map `fill` to a variable in your data using `aes()` and then use `labs()` to assign a label for fill:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = ____) +\n  geom_sf(aes(fill = ____)) +\n  labs(\n    ____\n  )\n```\n:::\n\n\nFinally, put all of these elements together with a theme function. `theme_minimal()` and `theme_void()` are good themes to use for maps but you can explore [all of the options in the ggplot2 documentation](https://ggplot2.tidyverse.org/reference/ggtheme.html):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = ____) +\n  geom_sf(mapping = aes(____)) +\n  labs(\n    title = ____,\n    caption = ____,\n    ____\n  ) +\n  ____\n```\n:::\n\n\n### Interactive plots with `{plotly}`\n\nWe aren't doing much with interactivity in this class (or exercise) but I did want to give you a chance to try it out using the `ggplotly()` function from the `{plotly}` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- ggplot(data = ____) +\n  geom____(aes(____))\n  \nplotly::ggplotly(\n  p = p\n)\n```\n:::\n\n\nA [directory of `{ggplot2}` extensions](https://exts.ggplot2.tidyverse.org/index.html) is available through the tidyverse website if you want to try more tools for animation or interactivity including [{gganimate}](https://gganimate.com/) or [{ggiraph}](https://davidgohel.github.io/ggiraph/).\n\n### Map making with `{ggplot2}`\n\nBy default, any map created with `geom_sf()` will show the graticulates on the map and axis labels with the coordinate values. Add data to this map and then hide these graticules by adding `theme_void()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = ____) +\n  geom_sf(color = \"black\", fill = NA) +\n  ____\n```\n:::\n\n\nYou can also hide or change [graticules](https://en.wikipedia.org/wiki/Graticule_(cartography)) by using `theme()`. Try setting the `panel.grid` argument to `element_blank()` to hide the grid:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = ____) +\n  geom_sf(color = \"black\", fill = NA) +\n  theme(\n    panel.grid = ____\n    )\n```\n:::\n\n\nNow, try \"zooming\" into a selected area of your map using the `xlim` and `ylim` arguments for `coord_sf()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = ____) +\n  geom_sf(color = \"black\", fill = NA) +\n  coord_sf(\n    xlim = ____,\n    ylim = ____\n  )\n```\n:::\n\n\nIf you have difficulty with this one, look back at [our week 2 slides](https://bldgspatialdata.github.io/website/slides/data-visualization.html#/8/6) for an example showing how to use `sf::st_bbox()` to get xmin, xmax, ymin, and ymax values for the xlim and ylim parameter.\n\n----\n\nUsing an inset map or \"locator map\" with a larger area and a zoomed in map showing a featured area is a common cartographic approach. You can use `patchwork::inset_element()` from the `{patchwork}` package to set this up:\n\n\n::: {.cell}\n\n```{.r .cell-code}\narea_map <- ggplot(data = ____) +\n  geom_sf(color = \"black\", fill = NA) +\n  coord_sf(\n    xlim = ____,\n    ylim = ____\n  )\n\ninset_map <- ggplot(data = ____) +\n  geom_sf(color = \"black\", fill = NA)\n\narea_map +\n  patchwork::inset_element(\n    p = inset_map,\n    left = ____,\n    bottom = ____,\n    top = ____,\n    right = ____\n  )\n```\n:::\n\n\nRemember, this format of calling functions (`<package name>::<function name>`) is just a shortcut for using functions from packages that *are* installed but not loaded into your environment. If you have any difficulty with this part of the exercise, make sure you have `{patchwork}` installed.\n\n---\n\nThere are some cases when you need to modify the geometry of your data as part of the process of making a map. The `st_simplify()` function is one way to do that. Try setting dTolerance to a low value, e.g. `dTolerance = 10`, and run the code block. Then try to run it again with `dTolerance = 100000`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusa <- filter(countries, NAME == \"United States of America\")\n\nsimple_usa <- st_simplify(x = usa, dTolerance = ____)\n\nggplot() +\n  geom_sf(\n    data = usa,\n    color = \"orange\"\n    ) +\n  geom_sf(\n    data = simple_usa,\n    color = \"purple\"\n  ) +\n  theme_void()\n```\n:::\n\n\nWhat happens when you increase the value of dTolerance? ____\n\nNow, let's try to same thing but smoothing features with `smoothr::smooth()` instead of simplifying with `sf::st_simplify()`. Start by setting smoothness to a small number, `smoothness = 0.5`, and then run again with higher and higher numbers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmooth_usa <- smoothr::smooth(x = usa, method = \"ksmooth\", smoothness = ____)\n\nggplot() +\n  geom_sf(\n    data = usa,\n    color = \"orange\"\n    ) +\n  geom_sf(\n    data = smooth_usa,\n    color = \"purple\"\n  ) +\n  theme_void()\n```\n:::\n\n\nWhat happens when you increase the value of smoothness? ____\n\nCheck the documentation for `st_simplify()` or `smoothr::smooth()` for more information on how these functions work to modify the geometry.\n\n## Bonus exercise\n\n### Creating maps with `{tmap}`\n\nPick one of the maps you created in the prior questions of this exercise and create a similar version using the `{tmap}` package.\n\nYou can install `{tmap}` the same as any other package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# pak::pkg_install(\"tmap\")\n```\n:::\n\n\nThen load the library:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tmap)\n```\n:::\n\n\nAnd make a map using data from `{rnaturalearth}` or another source of your choice:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n____\n```\n:::\n\n\nWhat is the same about making a map with `{tmap}` compared to `{ggplot2}`? ____\n\nWhat is different about making a map with `{tmap}` compared to `{ggplot2}`? ____\n\nDo you have any preference between the two? ____\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}