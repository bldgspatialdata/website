{
  "hash": "2b730434d40ddd1f145a432ad0045839",
  "result": {
    "engine": "knitr",
    "markdown": "---\norder: 3\ntitle: \"Transforming data with `{dplyr}` and `{tidyr}`\"\nsubtitle: \"Session {{< meta order >}}\"\ndate: 2023-09-13\nimage: \"images/whole-game.png\"\nexecute: \n  eval: false\n---\n\n\n\n\nThese slides are adapted from [Ch. 4 Data transformation](https://r4ds.hadley.nz/) in R for Data Science (2e).\n\n# Overview\n\n## Load `{dplyr}`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n:::\n\n\n\n\n## How can you transform your data using `{dplyr}`?\n\n-   Manipulate cases (rows)\n-   Manipulate variables (columns)\n-   Manipulate groups\n\n## Manipulate cases\n\n1.  `filter()`, which changes which rows are present without changing their order, and\n2.  `arrange()`, which changes the order of the rows without changing which are present.\n3.  `distinct()` which finds rows with unique values but unlike `arrange()` and `filter()` it can also optionally modify the columns.\n\n## Manipulate variables\n\n1.  `mutate()` creates new columns that are derived from the existing columns,\n2.  `select()` changes which columns are present,\n3.  `rename()` changes the names of the columns, and\n4.  `relocate()` changes the positions of the columns.\n\n## Manipulate groups\n\n-   `group_by()`,\n-   `summarize()`, and\n-   the `slice_()` family of functions.\n\n------------------------------------------------------------------------\n\n## The pipe\n\n. . .\n\n### |>\n\nThe base pipe was added as a base R function with version 4.1.0 released in 2021. For simple uses, the base pipe is identical to the pipe from the magrittr package.\n\n### %>%\n\nThe `%>%` pipe is part of the magrittr package which is loaded as part of the tidyverse. This operator has some additional features but they are less frequently used.\n\n# `select()`\n\nSelect (and optionally rename) variables in a data frame, using a concise mini-language that makes it easy to refer to variables based on their name (e.g. a:f selects all columns from a on the left to f on the right) or type (e.g. where(is.numeric) selects all numeric columns).\n\n------------------------------------------------------------------------\n\nSelect the variables to *keep*:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(storms, name, lat, long)\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\nSelect the variables to *drop* using `-` or `!`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(storms, !name)\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\nSelect a range of variables to keep using `:`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(storms, year:hour)\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\nUse helper functions from `{tidyselect}`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(storms, any_of(c(\"lat\", \"latitude\", \"y\", \"lon\", \"long\", \"longitude\", \"x\")))\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\nselect works with unquoted and quoted inputs:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(storms, wind)\nselect(storms, \"wind\")\nselect(storms, all_of(\"wind\"))\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\nselect doesn't work if you use the wrong variable names:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(storms, wnd)\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\nYour turn: use select to subset the variables for wind, pressure, tropical storm force diameter, and hurricane force dimeter.\n\n## Take a minute ⏰\n\n------------------------------------------------------------------------\n\nOK. Here is one answer:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(storms, wind, pressure, tropicalstorm_force_diameter, hurricane_force_diameter)\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\nHere is another answer:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(storms, wind:hurricane_force_diameter)\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\nAnd here is yet another answer:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(storms, wind, pressure, ends_with(\"diameter\"))\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\n# `filter()`\n\nThe `filter()` function is used to subset a data frame, retaining all rows that satisfy your conditions.\n\n------------------------------------------------------------------------\n\nUse a logical condition to get rows that return `TRUE`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(storms, wind >= 50)\n```\n:::\n\n\n\n\n### Use logical and and boolean operators to make conditions\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 == 1\n1 != 2\n1 < 2\n2 > 1\n2 <= 2\n2 >= 2\nis.na(NA_integer_)\n!is.na(1)\n1 %in% c(1, 2, 3)\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\nMultiple tests separated by commas are combined so the returned rows pass *all* tests:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(storms, month == 9, day == 13)\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\nYou *can* combine tests with a logical \"OR\" operator (`|`):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(\n  storms,\n  name == \"Eloise\" | name == \"Evelyn\",\n  day == 13\n)\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\nBut it may be easier to use write the condition using a different operator:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(\n  storms, name %in% c(\"Eloise\", \"Evelyn\"),\n  day == 13\n)\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\n![](https://media.npr.org/assets/img/2023/09/13/hurricane-lee-satellite-forecast-8d2596727e2cdc48cc53502417079144cffe96c7-s1600-c85.webp)\n\nYour turn: Hurricane Lee has **hurricane-force winds** extending up to 115 miles from its center and **tropical storm-force winds** extending for some 240 miles. Can you use filter to find the name and year of a hurricane with observed wind speeds that are the same or greater?\n\n## Take a minute ⏰\n\n------------------------------------------------------------------------\n\n...\n\n------------------------------------------------------------------------\n\nOK, here is an answer:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(\n  storms,\n  hurricane_force_diameter >= 115,\n  tropicalstorm_force_diameter >= 240\n)\n```\n:::\n\n\n\n\n## `mutate()`\n\n`mutate()` creates new columns that are functions of existing variables.\n\nIt can also modify (if the name is the same as an existing column) and delete columns (by setting their value to `NULL`).\n\n------------------------------------------------------------------------\n\nUse a function to add a new column based on existing variables:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(storms, ratio = pressure / wind)\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\n`mutate()` also has a `.before` or `.after` parameter allowing you to add the new variables before or after a selected variable or range of variables:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(storms, ratio = pressure / wind, .before = everything())\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\nWindow functions (also known as vectorized functions) are a group of functions that you can use with `{dplyr}`.\n\nFor example, `lag()` returns the previous value for a variable (effectively assumes the variable the observations are arranged in a meaningful order):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(\n  storms,\n  lag_status = lag(status)\n)\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\nThere is actually a problem with this new variable. Can you think what it is?\n\n------------------------------------------------------------------------\n\nIn this case, the `lag()` function needs to be applied to a grouped data frame or it may return a value from a different storm and different year:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(\n  storms,\n  lag_status = lag(status),\n  .by = c(year, name)\n)\n```\n:::\n\n\n\n\n### Types of vectorized functions to use with `mutate()`\n\n-   Offset, e.g. `lag()`\n-   Cumulative aggregate, e.g. `cumsum()`\n-   Ranking, e.g. `ntile()`\n-   Math, e.g. `between()`\n-   Other, e.g. `case_when()` (one of the best!)\n\n------------------------------------------------------------------------\n\n`case_when()` is an especially useful vector function with varied applications.\n\nFor example, we can use it to create new categorical variables based on continuous variables:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(\n  storms,\n  beaufort_desc = case_when(\n    wind < 1 ~ \"Calm\",\n    wind < 4 ~ \"Light Air\",\n    wind < 8 ~ \"Light Breeze\",\n    wind < 13 ~ \"Gentle Breeze\",\n    wind < 19 ~ \"Moderate Breeze\",\n    wind < 25 ~ \"Fresh Breze\",\n    wind < 32 ~ \"Strong Breeze\",\n    wind < 39 ~ \"Near Gale\",\n    wind < 47 ~ \"Gale\",\n    wind < 55 ~ \"Strong Gale\",\n    wind < 64 ~ \"Whole Gale\",\n    wind < 75 ~ \"Storm Force\",\n    .default = \"Hurricane Force\"\n  )\n)\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\n# `summarise()`, `group_by()`, and `slice_()`\n\n## `summarise()` \n\n`summarise()` creates a new data frame with:\n\n- one row for each combination of grouping variables; if there are no grouping variables, the output will have a single row summarising all observations in the input.\n- one column for each grouping variable\n- one column for each of the summary statistics that you have specified.\n\n------------------------------------------------------------------------\n\n`summarise()` works well with \"summary\" or analysis functions that take a vector and return a single value:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(\n  storms,\n  n_names = n_distinct(name),\n  max_category = max(category, na.rm = TRUE),\n  mean_lat = mean(lat),\n  mean_long = mean(long)\n)\n```\n:::\n\n\n\n\n### Types of analysis functions to use with `summarize()`\n\n-   Count\n-   Position\n-   Logical\n-   Order\n-   Rank\n-   Spread\n\n------------------------------------------------------------------------\n\nMost often you will want to use `summarise()` in combination with `group_by()`: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms |>\n  group_by(year) |>\n  summarise(\n    n_names = n_distinct(name),\n    max_category = max(category, na.rm = TRUE),\n    mean_lat = mean(lat),\n    mean_long = mean(long)\n  )\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\nYou can also use the `.by` parameter to define the groups for `summarise()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(\n  storms,\n  n_names = n_distinct(name),\n  max_category = max(category, na.rm = TRUE),\n  mean_lat = mean(lat),\n  mean_long = mean(long),\n  .by = year\n)\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\n`across()` is a helper function that you can use in combination with `mutate()` or `summarise()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(\n  storms,\n  across(\n    .cols = where(is.numeric),\n    .fns = list(\n      mean = mean,\n      median = median,\n      min = min,\n      max = max\n    )\n  )\n)\n```\n:::\n\n\n\n\n\n------------------------------------------------------------------------\n\n# Using data transformation functions with `sf` objects\n\nFirst convert storms into a `sf` object:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\noptions(tigris_use_cache = TRUE)\n\nstorms_sf <- st_as_sf(storms, coords = c(\"long\", \"lat\"), crs = 4326)\n\nus_states <- tigris::states()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms_sf <- st_transform(storms_sf, crs = 3857)\nus_states <- st_transform(us_states, crs = 3857)\n```\n:::\n\n\n\n\n## Using filter with `sf` objects\n\nIf you are just working with attributes (variables), `sf` objects work just like any other data frame:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(\n  storms_sf,\n  wind > 50\n)\n```\n:::\n\n\n\n\nBut, you can use a special set of predicate functions that work with `sf` objects to return a logical vector that also works with filter:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(\n  storms_sf,\n  as.logical(st_intersects(geometry, st_union(us_states), sparse = FALSE))\n)\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\nBy default, `st_intersects()` returns a matrix with the index for each value of the first parameter that intersects with each value of the second parameter.\n\nFor example, this takes each observation and checks if the POINT geometry intersects with each U.S. state:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_intersects(storms_sf, us_states)\n\ndim(st_intersects(storms_sf, us_states))\n```\n:::\n\n\n\n\n## Using mutate with `sf` objects\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms_usa <- storms_sf |>\n  mutate(\n    usa_observation = as.logical(\n      st_intersects(\n        geometry,\n        st_union(us_states),\n        sparse = FALSE\n      )\n    )\n  )\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms_usa |>\n  ggplot() +\n  geom_sf(aes(color = usa_observation), alpha = 0.5)\n```\n:::\n\n\n\n\n## Using summarise with `sf` objects\n\nYou can use summarise to combine geometry by grouping variables: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms_categories <- storms_sf |>\n  group_by(category) |>\n  summarise()\n\nstorms_categories\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms_categories |>\n  filter(!is.na(category)) |>\n  ggplot() +\n  geom_sf(aes(color = category), alpha = 0.5) +\n  scale_color_distiller(palette = \"PuRd\", direction = 1)\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\nYou can also work with the geometry column directly to modify the returned geometry.\n\nFor example, we can use `st_combine()` to turn the POINT geometry into MULTIPOINT geometry and then use `st_cast()` to transform the MULTIPOINT geometry into lines:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms_tracks <- storms_sf |>\n  group_by(year, name) |>\n  summarise(\n    geometry = st_cast(st_combine(geometry), to = \"LINESTRING\")\n  )\n\nstorms_tracks\n```\n:::\n\n\n\n\n------------------------------------------------------------------------\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms_tracks |>\n  ggplot() +\n  geom_sf(aes(color = year), alpha = 0.5)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}