{
  "hash": "a29ede03b15ee3594443cdd8e42ae7b8",
  "result": {
    "markdown": "---\ntitle: \"Session {{< meta order >}}: Visualizing spatial data with ggplot2\"\norder: 2\ndate-meta: 2023-09-06\nexecute: \n  error: true\nformat: \n  revealjs:\n    code-link: true\n    output-location: column-fragment\n    scrollable: true\n---\n\n::: {.cell}\n\n:::\n\n\n\n# Overview\n\n-   Why and how do we visualize spatial data?\n-   What is the \"grammar of graphics\"?\n-   How to use `{ggplot2}` to\n    -   build layered data visualizations\n    -   visualize spatial data\n\n# Why and how do we visualize spatial data?\n\n## Why do we visualize spatial data?\n\nWhy do we visualize spatial data?\n\n- Validation\n- Exploration\n- Communication\n\n----\n\n## Anscombe's quartet\n\nTo illustrate why visualization is essential, let's look at the Anscombe's Quartet data:\n\n\n::: {.cell}\n\n:::\n\n\n::: footer\nThis data is from the `{Tmisc}` package but can be found in many places.\n:::\n\n----\n\nHard to make sense of all those numbers at once.\n\nWhat if we use some summary statistics and get the mean, standard deviation, and Pearson correlation coefficient for x and y by set:\n\n\n::: {.cell}\n\n:::\n\n\n----\n\nNow, take another look using a plot:\n\n\n::: {.cell}\n\n:::\n\n\nWhat do you *see*?\n\n## How do we visualize spatial data?\n\n:::: {.columns}\n\n::: {.column width='50%'}\nA map is a special type of data visualization for spatial data but it isn't the only one.\n\n**Plots** and **tables** are two other common ways to visualize spatial data.\n:::\n\n::: {.column width='50%'}\n![Key for interpreting Sanborn fire insurance maps courtesy [Library of Congress](https://www.loc.gov/collections/sanborn-maps/about-this-collection/)](https://www.loc.gov/rr/geogmap/sanborn/images/sankey22c.jpg)\n:::\n\n::::\n\n----\n\n:::: {.columns}\n\n::: {.column width='40%'}\nGraphics can be further transformed using **animation** and **interactivity**. Maps, graphics, and tables also vary in **format**: print, web, mobile, etc.\n\n:::\n\n::: {.column width='60%'}\n![](https://media.giphy.com/media/xUA7aUs09Brz1ZED72/giphy.gif)\n:::\n\n::::\n\n# What is the \"grammar of graphics\"?\n\n![Image adapted from The Grammar of Graphics for Introduction to data visualisation with ggplot2 QCBS R Workshop Series](https://r.qcbs.ca/workshop03/book-en/images/gglayers.png)\n\n----\n\n- Data\n- Mapping\n- Statistics\n- Scales\n- Geometries\n- Facets\n- Coordinates\n- Theme\n\n::: footer\nThis introduction to the \"grammar of graphics\" is based largely on a 2020 ggplot2 workshop ([part 1](https://www.youtube.com/watch?v=h29g21z0a68)) by Thomas Lin Pedersen.\n:::\n\n## Data\n\n- Structure and representation of data determines what you can and can't do with it\n- Data is expected to be in a \"tidy\" format (also known as long format data)\n\n----\n\nA few definitions (from [Ch. 2 of R for Data Science](https://r4ds.hadley.nz/data-visualize)):\n\n-   variable: a quantity, quality, or property that you can measure.\n-   value: the state of a variable when you measure it. The value of a variable may change from measurement to measurement.\n-   observation: a set of measurements made under similar conditions\n-   tabular data: a set of values, each associated with a variable and an observation.\n\n----\n\nWhat works best with the grammar of graphics is **tidy data**:\n\n-   each value is placed in its own \"cell\",\n-   each variable in its own column, and\n-   each observation in its own row.\n\n## Mapping\n\n- Allow data to be understood by the graphics system through:\n\n  - Aesthetic mapping: variables -> graphical properties in the geometry\n  - Facet mapping: variables -> panels in layout\n\n## Statistics\n\n- Data may not represent the displayed values\n\n- Statistics transform input variables into displayed values, e.g.\n\n  - Counting the number of observations by category\n  - Calculating summary statistics for a boxplot\n  \n::: footer\nStatistics can be used prior to plotting data or used by a plotting function directly.\n:::\n\n## Scales\n\n- Scales translate between value ranges and graphical properties, e.g.\n\n  - Categories -> Colors\n  - Numbers -> Position\n  \n- Scales use a specific type of interpolation, e.g. discrete, continuous, etc., so not all scales work with all variables.\n\n::: footer\nIn the not too common case where data directly represents a graphical property, e.g. a \"color\" column, you can use a special type of scale called an \"identity\" scale.\n:::\n\n## Geometries\n\n- How translate aesthetics into graphical representations\n\n- Basic geometries (e.g. points, lines, polygons) can be combined into more complex geometries (e.g. box plot, map)\n\n- Typically, the geometries are the same as the \"type\" of plot\n\n## Facets\n\n- Defines how data is split across multiple panels\n\n## Coordinates\n\n- Positional aesthetics must be interpreted by a coordinate system\n\n- Defines the physical mapping of aesthetics to the paper\n\n::: footer\nWe usually think about the [cartesian coordinate system](https://en.wikipedia.org/wiki/Cartesian_coordinate_system)â€”but there are a lot of different kinds of coordinate systems.\n:::\n\n## Theme\n\n- Every part of the graphic that *isn't* linked to the data:\n\n  - Fonts\n  - Spacing\n  - Colors \n  - Weights\n  - etc.\n\n# How to to use `{ggplot2}` to...\n\n-   build layered data visualizations\n-   visualize spatial data\n\n# Build layered data visualizations\n\n## Setup packages\n\nFor this session, we are going to use the `{ggplot2}` and `{dplyr}` packages:\n\n\n::: {.cell output-location='default'}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(sf)\n```\n:::\n\n\n## Setup data\n\nWe are also going to use the `storms` data included with `{dplyr}`.\n\nTake a quick look at `storms` using `glimpse()`:\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nglimpse(storms)\n```\n:::\n\n\n::: footer\nWhen we use `storms`, it is important to remember that each row is an **observation** of a storm, not a summary feature for an individual storm.\n:::\n\n----\n\n![](https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExaWtjY2dycDRzZ2djNHQ4MDh6Nm50dGYzbWF4ZHNkNGdkc3N2azB3OSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/7j0i4tSogPfq9rDxsB/giphy.gif)\n\n::: footer\n`storms` is a subset of a larger [Atlantic hurricane database (HURDAT2)](https://www.nhc.noaa.gov/data/#hurdat) with data from 1851 to 2022. Since 1974, NOAA's [Geostationary Operational Environmental Satellite](https://en.wikipedia.org/wiki/Geostationary_Operational_Environmental_Satellite) program has played a key role in tracking storms and monitoring weather around the world.\n:::\n\n## Create a ggplot\n\nWe can start by using the function `ggplot()` to define a plot object. Set `storm` as the input data for `ggplot()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = storms)\n```\n:::\n\n\n. . .\n\n::: {.smaller}\nWell, that doesn't look like much. ðŸ¤”\n\nThis is the first step in creating a plot that we can add layers to. Parameters set with `ggplot()` can be \"inherited\" by layers added later.\n:::\n\n## Add aesthetics and layers\n\n### Set mapping with `aes()`\n\nNext, we can set the mapping using the `aes()` function. We can start by mapping `long` (longitude) to `x` and `lat` (latitude) to `y`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = storms,\n  mapping = aes(\n    x = long,\n    y = lat\n  )\n)\n```\n:::\n\n\nBefore we can see any data, we need to tell `ggplot()` how we want to represent the data using layers.\n\n::: notes\nThe mapping argument of the ggplot() function defines how variables in your dataset are mapped to visual properties (aesthetics) of your plot.\n:::\n\n----\n\nLayers in `{ggplot2}` are most often added using \"geoms\" (short for geometry) functions like `geom_point()`, `geom_col()`, or `geom_histogram()`.\n\nLet's give it a try using `geom_point()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = storms,\n  mapping = aes(\n    x = long,\n    y = lat\n  )\n) +\n  geom_point()\n```\n:::\n\n\n----\n\nYou can define the `data` and `mapping` parameters globally using `ggplot()` or locally for a single geom function. This code does the exact same thing as the prior block:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_point(\n    mapping = aes(\n      x = long,\n      y = lat\n    ),\n    data = storms\n  )\n```\n:::\n\n\n----\n\n### What is this `+` operator?\n\nNotice that we are combining the `ggplot()` and `geom_point()` functions using the `+` operator. This is a style of function or operator known as an [infix operator](https://en.wikipedia.org/wiki/Infix_notation).\n\nNext week, we will introduce a similar function known as a pipe, `%>%` or `|>` that works to pass the output from one function (or line of code) into the next line as the first parameter in a function.\n\n----\n\nFor example, see how we can use a series of pipes to operate on the storms data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms |>\n  distinct(name)\n```\n:::\n\n\n----\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms |>\n  distinct(name) |> \n  nrow()\n```\n:::\n\n\n----\n\nThe prior block is the same as the following block:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorm_names <- distinct(storms, name)\nnrow(storm_names)\n```\n:::\n\n\n::: footer\nUsing pipes can help avoid the need for intermediate objects like `storm_names` that might only exist to move the output of one function to the input for another function.\n:::\n\n----\n\nThe first parameter for `ggplot()` is `data` and the first parameter for all geom functions is `mapping` so you often see these passed as unnnamed parameters:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(storms) +\n  geom_point(\n    aes(\n      x = long,\n      y = lat\n    )\n  )\n```\n:::\n\n\n---\n\nYou can even leave off the x and y parameter names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(storms) +\n  geom_point(aes(long, lat))\n```\n:::\n\n\n----\n\n# Mapping variables are not strings!\n\nThe variables passed to `aes()` don't have quotes around them! This is because `aes()` is a data-masking (also known as a quoting function) where the inputs are evaluated in the context of the data.\n\nTLDR: only put quotes around your aesthetic mappings when you want to pass a literal string.\n\n----\n\nNext we can map one of the variables (`status` or storm classification) to an aesthetic (`color`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(storms) +\n  geom_point(aes(long, lat, color = status))\n```\n:::\n\n\nNote that we now have a legend, added automatically when we defined a mapping to color. Since color is not a \"positional aesthetic\" we can't easily interpret the meaning of the graphic without a legend, labels, or annotations.\n\n\n----\n\nIn addition to having mapped aesthetics, we can also have \"fixed\" aesthetics (fixed because the same value is used for every observation in the plot). When you have a lot of overlapping features (known as overplotting), you may want to reduce the `alpha` (or transparency) of the features:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(storms) +\n  geom_point(\n    aes(x = long,\n    y = lat,\n    color = status),\n  alpha = 0.4\n  )\n```\n:::\n\n\nFixed aesthetics should be defined for each geomâ€”they are ignored if you pass them to `ggplot()`.\n\n----\n\nAesthetics can also be defined using a function. In this example, we are using the boolean operator `==` to compare the values from \"status\" to the string \"hurricane\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = storms,\n  mapping = aes(\n    x = long,\n    y = lat,\n    color = status == \"hurricane\"\n  )\n) +\n  geom_point()\n```\n:::\n\n\n\n## Visualizing distributions\n\n## Distribution of one numeric variable\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = storms,\n  mapping = aes(y = lat)\n) +\n  geom_histogram(bins = 90)\n```\n:::\n\n\n## Distribution of one numeric variable\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = storms,\n  mapping = aes(x = lat)\n) +\n  geom_freqpoly(binwidth = 1)\n```\n:::\n\n\n## Distribution of one categorical variable\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  data = storms,\n  mapping = aes(y = category)\n) +\n  geom_bar()\n```\n:::\n\n\n# Visualize spatial data\n\nTo start, let's convert our storms data set from a data frame into a sf object using `sf::st_as_sf()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms_sf <- sf::st_as_sf(\n    storms,\n    coords = c(\"long\", \"lat\"),\n    crs = 4326\n  )\n```\n:::\n\n\n:::{.callout-tip collapse=false appearance='default' icon=true}\n# Always supply coordinates with longitude before latitude!\n`sf::st_as_sf()` requires that you supply coordinates in lon lat order. This is also the standard order for GeoJSON files, Shapefiles, and KML files. Check out [lon lat lat lon by Tom MacWright](https://macwright.com/lonlat/) for more information.\n:::\n\n----\n\nFinally, we can look at these observations on a map:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = storms_sf) +\n  geom_sf(aes(color = status))\n```\n:::\n\n\n----\n\nThat first map may not look much different.\n\nBut converting the data to a `sf` object allows us to use `coord_sf()` to transform the coorindate reference system on the fly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = storms_sf) +\n  geom_sf(aes(color = status)) +\n  coord_sf(crs = \"EPSG:3035\")\n```\n:::\n\n\n----\n\nThis is equivalent to converting the coordinate reference system in advance using `st_transform()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms_sf |> \n  st_transform(2804) |> \n  ggplot() +\n  geom_sf(aes(color = status))\n```\n:::\n\n\nNote, that this is another example of how we can use the pipe (`|>`) to move data between functions in R.\n\n----\n\nHowever, to really show the potential, we need some more data. Install and load the `{rnaturalearth}` package and then load data for the coastline and countries:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# pak::pkg_install(c(\"rnaturalearth\", \"rnaturalearthdata\"))\nlibrary(rnaturalearth)\n\ncoastline <- ne_coastline(returnclass = \"sf\")\n\ncountries <- ne_countries(returnclass = \"sf\")\n```\n:::\n\n\n----\n\nPut them together and we are starting to get somehwere:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = storms_sf, aes(color = status)) +\n  geom_sf(data = coastline, color = \"white\")\n```\n:::\n\n\n----\n\nBut the map is zoomed out to show the whole worldâ€”not just the north Atlantic storm observations. We can use the xlim and ylim parameters of `coord_sf()` to \"zoom\" in on a smaller area:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms_bbox <- storms_sf |> \n  st_transform(\"EPSG:3035\") |> \n  st_bbox()\n\nstorms_map <- ggplot() +\n  geom_sf(data = countries, fill = \"white\") +\n  geom_sf(data = storms_sf, aes(color = category), alpha = 0.3) +\n  geom_sf(data = coastline, color = \"black\") +\n  coord_sf(\n    xlim = c(storms_bbox$xmin, storms_bbox$xmax),\n    ylim = c(storms_bbox$ymin, storms_bbox$ymax),\n    crs = \"EPSG:3035\"\n    )\n\nstorms_map\n```\n:::\n\n\n----\n\nTry adding a scale:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms_map <- storms_map +\n  scale_color_distiller(type = \"seq\", direction = 1, palette = \"YlOrRd\", na.value = \"gray60\")\n\nstorms_map\n```\n:::\n\n\n----\n\nNow try adding some labels:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms_map <- storms_map +\n  labs(\n    title = \"Atlantic hurricanes by category, 1975-2021\",\n    caption = \"Data: NOAA Atlantic hurricane database best track data via the {dplyr package}\"\n  )\n\nstorms_map\n```\n:::\n\n\n----\n\nLastly, we can adjust the theme:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n storms_map +\n  theme_minimal() +\n  theme(\n    legend.position = \"bottom\"\n  )\n```\n:::\n\n\n\n----\n\n:::: {.columns}\n\n::: {.column width='40%'}\n![](https://images.routledge.com/common/jackets/amazon/978036749/9780367494759.jpg)\n:::\n\n::: {.column width='60%'}\n\"It's true that there are better and worse ways to make a map but **no one way to make an excellent map**.\"\n\nGretchen N. Peterson in GIS Cartography: A Guide to Effective Map Design\n:::\n\n::::\n\n----\n\nWhat makes a bad map *bad*?\n\nFor new map makers who might not know any better, it is often:\n\n- Confusing or distracting layout\n- Not enough color contrast for features\n- Cluttered labels, legends, or features\n\n----\n\nWhat makes a fine map *just* fine?\n\nFor more experienced map makers who might be in a hurry:\n\n- Not enough thought on font sizes and styling\n- No feature generalization (simplifying geometry where appropriate for the map scale or subject)\n- Inappropriate color scales\n\n----\n\nThere are many cartographic considerations that also apply to other all types of data visualization:\n\n- Layout\n- Fonts (Typography)\n- Colors\n- Output formats\n\n----\n\nBut there are also some cartographic considerations that apply to maps in special and important ways: \n\n- Feature geometry (and cartographic conventions)\n- Projections\n- Scaling\n",
    "supporting": [
      "data-visualization_files/figure-revealjs"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}