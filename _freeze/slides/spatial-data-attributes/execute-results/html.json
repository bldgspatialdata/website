{
  "hash": "2971091df26ecfc8d3340846bc871a89",
  "result": {
    "markdown": "---\ntitle: \"Creating and manipulating attributes for spatial data\"\norder: 4\neditor: visual\nexec:\n  eval: false\n---\n\n\n## Setup\n\nToday, we are going to use the `{tidyverse}` along with `{sf}` and two\nrelated packages: `{lwgeom}` and `{units}`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(lwgeom)\nlibrary(units)\n```\n:::\n\n\n------------------------------------------------------------------------\n\n## Getting started\n\nFor this session, we also need some data to look at. We are going to\nload data from the U.S. Census Bureau using the `{tigris}` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tigris)\noptions(tigris_use_cache = TRUE)\n```\n:::\n\n\n------------------------------------------------------------------------\n\nUse `states()` to load data on U.S. states and `primary_roads()` to load\ndata on U.S. highways:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nus_states <- states()\n\nus_highways <- primary_roads()\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n## Things to remember about spatial data\n\n-   Fields\n-   Objects\n\nCheck out the [Wikipedia article on data models in\nGIS](https://en.wikipedia.org/wiki/Data_model_(GIS)) for more background\non this topic.\n\n## Things to remember about `sf` and `sfc` objects\n\nA `sf` object is a data frame with a `sfc` list-column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nus_states$geometry\n```\n:::\n\n\n## Things to remember about `sf` and `sfc` objects\n\n-   a `sf` object is a data frame with a `sfc` list-column\n-   a `sf` object has a `sf_column` attribute (it isn't always named\n    geometry---use `attributes()` to take a look)\n\n------------------------------------------------------------------------\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(us_states)\n```\n:::\n\n\n## Things to remember about `sf` and `sfc` objects\n\n-   a `sf` object is a data frame with a `sfc` list-column\n-   a `sf` object has a `sf_column` attribute (it isn't always named\n    geometry---use `attributes()` to take a look)\n-   `sf` and `sfc` objects use a coordinate reference system\n\n------------------------------------------------------------------------\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(us_states)\n\nst_crs(us_states$geometry)\n```\n:::\n\n\n## Things to remember about `sf` and `sfc` objects\n\n-   a `sf` object is a data frame with a `sfc` list-column\n-   a `sf` object has a `sf_column` attribute (it isn't always named\n    geometry---use `attributes()` to take a look)\n-   `sf` and `sfc` objects use a coordinate reference system\n-   working with `sf` objects is *slower* than working with data\n    frames---so drop the geometry if you don't need it\n\n------------------------------------------------------------------------\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_drop_geometry(us_states)\n```\n:::\n\n\n## Things to remember about coordinate reference systems\n\n-   objects *must* share the same coordinate reference system if you are\n    using them together\n-   coordinate reference systems are stored as attributes for `sfc` and\n    `sf` objects (`sfg` objects don't have a CRS)\n-   coordinate reference systems have *units*\n-   geographic and projected coordinate reference systems are *not* the\n    same\n-   coordinate reference systems can be missing and they can be wrong\n\n------------------------------------------------------------------------\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# bad: assigning a CRS that doesn't match the geometry\nst_crs(us_states) <- 3857\n\n# good: using st_transform to convert the geometry to a new CRS\nst_transform(us_states, crs = 3857)\n```\n:::\n\n\n------------------------------------------------------------------------\n\nGet the objects into the same CRS before we continue:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nus_states <- st_transform(us_states, crs = 3857)\n\nus_highways <- st_transform(us_highways, crs = 3857)\n```\n:::\n\n\n## Things to think about\n\n-   `sf` objects are *not* the only way to represent spatial data in R\n\n-   If you are working with more than one `sf` or `sfc`, the objects\n    must use the *same* coordinate reference system to use them\n    together.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# state\n```\n:::\n\n\n## What is an \"attribute\" in GIS?\n\nWithin a GIS desktop application, an **attribute** may be known as a\n**field**.\n\nWhen we talk about tidy data frames, an attribute is equivalent to a\n**variable** which is represented as a **column** in a data frame.\n\n::: notes\nhttps://support.esri.com/en-us/gis-dictionary/attribute\n\n-   \\[data models\\] Nonspatial information about a geographic feature in\n    a GIS, usually stored in a table and linked to the feature by a\n    unique identifier. For example, attributes of a river might include\n    its name, length, and sediment load at a gauging station.\n-   \\[data models\\] In raster datasets, information associated with each\n    unique value of a raster cell.\n-   \\[graphics (map display)\\] Information that specifies how features\n    are displayed and labeled on a map; for example, the graphic\n    attributes of a river might include line thickness, line length,\n    color, and font for labeling.\n:::\n\n------------------------------------------------------------------------\n\n**But!** Feature geometry is also stored as a column.\n\nA single `sfc` object (or list-column) can contain more than one feature\n(shapefiles can't do this BTW!) using MULTIPOINT, MULTILINESTRING,\nMULTIPOLYGON, or GEOMETRYCOLLECTION geometry types.\n\n------------------------------------------------------------------------\n\n**And!** Objects in R can also have attributes and these are *not* the\nsame thing as attributes for spatial data. Try not to get them mixed up.\n\n## What is an attribute?\n\nSo (to recap) an *attribute* in GIS can also be called a...\n\n-   ...**field** in a desktop GIS application\n-   ...**variable** in tidy data\n-   ...**column** in a data frame\n\n## What types of attributes exist?\n\nAttributes are \"properties of features ('things') that do not describe\nthe feature's geometry\".\n\nHere are the attributes for `us_states`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(st_drop_geometry(us_states))\n```\n:::\n\n\n------------------------------------------------------------------------\n\nAttributes can have:\n\n-   **point support:** the value applies to every point *individually*,\n    or\n-   **block support:** the value is a summary for *all* points in the\n    geometry\n\n------------------------------------------------------------------------\n\nThe relationship between attributes and geometry can be described as:\n\n-   **constant:** the value is valid everywhere in or over the geometry\n-   **aggregate:** the value is associated with the entire geometry\n\n------------------------------------------------------------------------\n\nWhat is an example of an attribute with a constant relationship?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(us_states)\n```\n:::\n\n\n::: notes\n-   NAME, REGION, or DIVISION: Yes - every part of a state can still use\n    the same state name\n-   ALAND: No - this is an aggregate value\n-   INTPTLAT: No - this is a summary value\n:::\n\n------------------------------------------------------------------------\n\nWhat is an example with an aggregate relationship?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(us_states)\n```\n:::\n\n\n::: notes\n-   NAME, REGION, or DIVISION: Yes - every part of a state can still use\n    the same state name\n-   ALAND or AWATER: Yes - this is an aggregate value - if the shape of\n    the state changed, the land area would change\n-   INTPTLAT or INTPTLON: Yes - this is a summary value - if the shape\n    of the state changed, the interior latitude/longitude point would\n    change\n\nIllustrates the point: \"A typical property of such variables is that\nassociated geometries come for instance from legislation, observation\ndevices or analysis choices, but not intrinsically from the observed\nvariable.\"\n:::\n\n------------------------------------------------------------------------\n\nAttributes can be:\n\n-   extensive: corresponding to amounts, associated with a physical size\n    (length, area, volume, counts of items)\n-   intensive:\n\n## What is an \"attribute domain\"?\n\n::: notes\n-   \\[data structures\\] In a geodatabase, a mechanism for enforcing data\n    integrity. Attribute domains define what values are allowed in a\n    field in a feature class or nonspatial attribute table. If the\n    features or nonspatial objects have been grouped into subtypes,\n    different attribute domains can be assigned to each of the subtypes.\n:::\n\n## What are we working with?\n\nWhen we do data analysis using `{dplyr}`, there are three types of\nfunctions we use most often:\n\n-   Boolean operators or predicates\n-   Window or vector functions\n-   Summary or analysis functions\n\nThere are similar\n\n## Predicate functions for geometries with `{sf}`\n\n`{sf}` includes \"vectorized\" logical operators or tests that work with\ngeometry including:\n\n-   `st_is()`\n-   `st_is_valid()`\n-   `st_is_empty()`\n\n------------------------------------------------------------------------\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_is(us_states, \"POLYGON\")\n\nst_is(us_states, \"MULTIPOLYGON\")\n```\n:::\n\n\n## Predicate functions for geometries with `{sf}`\n\n`{sf}` also includes more than a dozen predicate functions for working\nwith *pairs* of simple geometries including:\n\n-   `st_intersects`\n-   `st_disjoint`\n-   `st_contains`\n-   `st_covers`\n-   `st_is_within_distance`\n\n## Using predicate functions for spatial joins and filters\n\n`st_filter()` and `st_join()` are two functions that rely on these\npredicate functions to work.\n\n------------------------------------------------------------------------\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaryland <- filter(us_states, NAME == \"Maryland\")\n\nst_filter(us_highways, maryland)\n```\n:::\n\n\n------------------------------------------------------------------------\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_filter(us_states, maryland, .predicate = st_disjoint)\n```\n:::\n\n\n## Creating new variables with geometry\n\n-   Measuring feature geometries\n-   Comparing feature geometries\n-   Joining data based on feature geometries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaryland <- filter(us_states, NAME == \"Maryland\")\n```\n:::\n\n\n## Measuring geometries with `{sf}`\n\n## Measuring geometries with `{sf}`\n\n`{sf}` includes a few different functions for measuring geometries:\n\n-   `st_area()` (only works with POLYGON and MULTIPOLYGON geometries)\n-   `st_length()` (only wrks with LINESTRING and MULTILINSTRING\n    geometries)\n-   `st_distance()` (requires a pair of objects)\n\n## Measuring geometries with `{sf}`\n\nAll of these functions are *vectorized* meaning that they can operate\nindependently on each feature in a `sf` or `sfc` object.\n\nThey support both `sf` inputs (data frames) *and* `sfc` inputs\n(lists)---but they always return a vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_area(maryland)\n\nst_area(maryland$geometry)\n```\n:::\n\n\n## Measuring geometries with `{sf}`\n\nBut, remember, `dplyr::mutate()` is designed to work with vectorized\nfunctions so you can do us a measurement function inside `mutate()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaryland |> \n  mutate(\n    area = st_area(geometry)\n  )\n```\n:::\n\n\n## Measuring geometries with `{sf}`\n\nYou can even work with multiple geometries using this same approach:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nus_states |> \n  mutate(\n    area = st_area(geometry),\n    distance_to_maryland = st_distance(geometry, maryland)\n  )\n```\n:::\n\n\nThis works to aggregate features by division:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nus_states |> \n  group_by(DIVISION) |> \n  summarise(\n    n_states = n_distinct(NAME)\n  ) \n```\n:::\n\n\n------------------------------------------------------------------------\n\n\n::: {.cell}\n\n```{.r .cell-code}\nus_states |> \n  group_by(DIVISION) |> \n  summarise(\n    n_states = n_distinct(NAME)\n  ) |> \n  ggplot() +\n  geom_sf(aes(fill = DIVISION)) +\n  theme_minimal()\n```\n:::\n\n\n------------------------------------------------------------------------\n\nThis doesn't entirely work (yet):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nus_states |> \n  group_by(DIVISION) |> \n  summarise(\n    n_states = n_distinct(NAME)#,\n    # .by = DIVISION\n  )\n```\n:::\n\n\n------------------------------------------------------------------------\n\nBut *this* (explicitly unioning the geometry) does work:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nus_states |> \n  summarise(\n    n_states = n_distinct(NAME),\n    geometry = st_union(geometry),\n    .by = DIVISION\n  )\n```\n:::\n\n\n------------------------------------------------------------------------\n\n\n::: {.cell}\n\n```{.r .cell-code}\nus_states |> \n  group_by(DIVISION) |> \n  summarise(\n    n_states = n_distinct(NAME),\n    geometry = st_union(geometry),\n    .by = DIVISION\n  ) |> \n  st_as_sf() |> \n  ggplot() +\n  geom_sf(aes(fill = DIVISION)) +\n  theme_minimal()\n```\n:::\n\n\n## Measuring geometries with `{sf}`\n\nNot all functions work with all geometry types!\n\n-   `st_area()` only works with POLYGON and MULTIPOLYGON geometries\n-   `st_length()` only wrks with LINESTRING and MULTILINSTRING\n    geometries\n\n## Measuring geometries with `{sf}`\n\nNot all functions always return a vector. Try\n\n\n::: {.cell}\n\n:::\n\n\n-   `st_distance()` requires at least two objects\n\n## Measuring geometries with `{lwgeom}` and `{geosphere}`\n\n-   `lwgeom::st_perimeter()`\n-   `geosphere::bearing()`\n\n------------------------------------------------------------------------\n\n\n::: {.cell}\n\n```{.r .cell-code}\nus_states |> \n  group_by(DIVISION) |> \n  summarise(\n    n_states = n_distinct(NAME)\n  )\n```\n:::\n\n\n------------------------------------------------------------------------\n\n\n::: {.cell}\n\n:::\n\n\n## Compute geometric measurements\n\n`{sf}` works well with the `{tidyverse}`---but there are some things to\nknow.\n\n------------------------------------------------------------------------\n\nYour geometry column sticks around, even if you don't select it\n\n-   \n\nIf you lose your sf class, but you still have your geometry, convert\nfrom a data frame to a sf object with `st_as_sf()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nus_states |> \n  mutate(\n    area = st_area(geometry)\n  )\n```\n:::\n\n\nneighborhoods \\|\\> distinct(type, .keep_all = TRUE) \\|\\> class()\nmapview::mapview()\n\n## More things to remember\n\n-   \"attributes\" in GIS and attributes in R are *different* things.\n-   Outside of today's lecture, I will typically talk about variables or\n    columns---but not attributes.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}